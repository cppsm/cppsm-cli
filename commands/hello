#!/bin/bash -e

# shellcheck source=.settings
. "${BASH_SOURCE%/*}/.settings"

if [ "$#" -ne 0 ] || \
     [ ! -f CMakeLists.txt ] || \
     [ -e equipment ] || \
     [ -e internals ] || \
     [ -e provides ] || \
     [ -e requires ] ; then
  CMD="${0##*/}"
  cat << EOF
Usage: $CMD

Creates an example "Hello, world!" program in a freshly initialized project
directory.
EOF
  exit 1
fi

mkdir -p provides/include/message_v1

cat << EOF > provides/include/message_v1/hello.hpp
#include <string>

namespace message_v1 {

std::string hello(const std::string &to);

}
EOF

mkdir -p provides/library

cat << EOF > provides/library/hello.cpp
#include "message_v1/hello.hpp"

std::string message_v1::hello(const std::string &to) {
  return "Hello, " + to + "!";
}
EOF

cat << EOF > provides/CMakeLists.txt
add_conventional_library(message_v1)
EOF

"$CPPSM/commands/add" equipment https://github.com/per-framework/testing.cpp.git v1

mkdir -p internals/testing

cat << EOF > internals/testing/message_test.cpp
#include "message_v1/hello.hpp"

#include "testing_v1/test.hpp"

using namespace testing_v1;

auto hello_test =
    test([]() { verify("Hello, there!" == message_v1::hello("there")); });
EOF

mkdir -p internals/program

cat << EOF > internals/program/hello.cpp
#include "message_v1/hello.hpp"

#include <iostream>

int main() {
  std::cout << message_v1::hello("world") << std::endl;
  return 0;
}
EOF

cat << EOF > internals/CMakeLists.txt
add_conventional_executable_tests(PRIVATE message_v1 testing_v1)

add_conventional_executable(hello)
target_link_libraries(hello PRIVATE message_v1)
EOF
